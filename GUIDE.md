# FORGE — Руководство пользователя

## Что такое Forge

Forge — это плагин для Claude Code, который превращает ваши проекты в "самодокументирующиеся системы". Вместо того, чтобы Claude каждый раз заново читал весь код и пытался понять структуру проекта (тратя десятки тысяч токенов), Forge создаёт компактную документацию: карту проекта, правила разработки, текущее состояние. Claude читает эту документацию (~2000 токенов вместо ~40000+) и сразу понимает, с чем имеет дело. Плюс Forge даёт структурированные процессы для разработки: от идеи через дизайн и план до готового кода с тестами.

## Установка

Forge устанавливается как обычный плагин Claude Code:

```bash
# Клонируйте репозиторий
git clone https://github.com/obra/forge

# Перейдите в директорию плагина
cd forge/forge-plugin

# Установите плагин (создаст симлинк в ~/.claude/plugins/)
# Способ зависит от вашей ОС - см. документацию Claude Code
```

После установки перезапустите Claude Code. Плагин Forge будет доступен автоматически во всех проектах.

## Первый запуск

### Шаг 1: Инициализация проекта

Откройте ваш проект в Claude Code и выполните:

```
/forge:init
```

Claude:
- Просканирует структуру вашего проекта
- Спросит, какие файлы являются "красными зонами" (критичные, требующие особой осторожности)
- Спросит о языке и соглашениях именования
- Создаст структуру документации в папке `docs/`

### Что создаётся при инициализации

```
docs/
├── map.json              # Карта проекта: структура, количество файлов, красные зоны
├── conventions.json      # Правила: стиль кода, паттерны, архитектурные решения
├── state.json            # Текущее состояние: над чем работаете, что сделано, что осталось
├── history.log           # История сессий (лог, Claude не читает)
├── plans/                # Дизайн-документы и планы реализации
└── library/              # Машинночитаемые спецификации файлов
    ├── indicators/
    │   └── spec.json
    └── strategies/
        └── spec.json
```

Plus в каждой папке с кодом появится `README.md` — простое описание на русском, что в этой папке и зачем.

### Пример инициализации

```
Вы: /forge:init

Claude: Я просканировал проект. Какие файлы отметить как красные зоны?

Красные зоны — это файлы:
- От которых зависит production (точное поведение критично)
- Сложные и хрупкие (высокий риск сломать)
- Требующие тщательного ревью перед изменением

Например: core алгоритмы, production конфиги, модели данных

Перечислите пути к файлам (по одному в строке) или 'none':

Вы: src/core/trading_engine.py
src/strategies/production_strategy.py
none

Claude: Какой язык/фреймворк использует проект?

Вы: python

Claude: Какие соглашения именования?

Вы: default

Claude:
✓ FORGE документация инициализирована

Создано:
- docs/map.json (3 директории, 2 красные зоны)
- docs/conventions.json (python)
- docs/state.json
- docs/history.log
- docs/library/ (3 директории документированы)

Ваш проект теперь имеет контекстную документацию.
```

## Команды

### /forge:init

**Что делает:** Создаёт структуру документации FORGE для проекта.

**Когда использовать:** Один раз при первой настройке проекта с Forge.

**Пример:**
```
Вы: /forge:init
Claude: [создаёт docs/map.json, conventions.json, state.json, library/]
```

### /forge:sync

**Что делает:** Обновляет документацию после ваших изменений в коде. Смотрит на git diff, читает изменённые файлы, обновляет spec.json и README.md, обновляет карту проекта.

**Когда использовать:** После завершения фичи, перед мержем, в конце рабочей сессии.

**Пример:**
```
Вы: /forge:sync

Claude: Я проверил изменения с последнего sync. Обнаружено:
- Создано: indicators/macd.py, tests/test_macd.py
- Изменено: strategies/rsi_strategy.py

[Запускает subagent для обновления документации]

Claude: Над чем вы сейчас работаете?

Вы: Добавляю индикатор MACD

Claude: Какой прогресс?

Вы: 3 из 5 шагов готово

Claude: Что ещё осталось?

Вы: Подключить MACD к стратегии
Добавить бэктест

Claude:
✓ FORGE документация синхронизирована

Обновлено:
- docs/library/ (2 директории)
  - Создано: 2 файла
  - Изменено: 1 файл
- docs/map.json (обновлены счётчики)
- docs/state.json (текущая задача: Добавляю индикатор MACD)
```

### /forge:brainstorm

**Что делает:** Запускает скилл brainstorming — помогает превратить идею в чёткий дизайн. Claude задаёт вопросы, уточняет требования, предлагает 2-3 подхода, получает ваше одобрение, записывает дизайн-документ.

**Когда использовать:** Перед любой новой фичей, перед началом реализации, когда есть идея но нет чёткого плана.

**Пример:**
```
Вы: /forge:brainstorm
Хочу добавить аутентификацию через JWT

Claude: Я использую скилл brainstorming.

[Читает docs/map.json, conventions.json, state.json]

Уточню что вы хотите построить: система аутентификации с JWT токенами,
которая позволит пользователям логиниться и получать доступ к защищённым
эндпоинтам. Правильно?

Вы: Да

Claude: Где должны храниться токены на клиенте?

1. localStorage
2. httpOnly cookies
3. sessionStorage

Вы: 2

Claude: [задаёт ещё несколько вопросов]

Claude: У меня есть 2 подхода:

**Подход 1 (рекомендую):** Использовать Flask-JWT-Extended...
[описание]

**Подход 2:** Написать свою реализацию JWT...
[описание]

Рекомендую подход 1 — проверенная библиотека, меньше ошибок.

Вы: Согласен, подход 1

Claude: [Представляет дизайн по секциям, после каждой спрашивает одобрение]

Вы: Выглядит хорошо

Claude: Сохранил дизайн в docs/plans/2026-02-15-jwt-auth-design.md

Теперь создам план реализации.
[Вызывает /forge:write-plan автоматически]
```

### /forge:write-plan

**Что делает:** Создаёт детальный план реализации из дизайн-документа. План разбит на мелкие задачи (2-5 минут каждая) с точными командами, ожидаемым выводом, путями к файлам.

**Когда использовать:** Автоматически вызывается после brainstorming. Можно вызвать вручную если есть готовый дизайн.

**Пример:**
```
Claude: План готов и сохранён в docs/plans/2026-02-15-jwt-auth.md

Перед выбором способа выполнения:
Запустите /forge:discover для поиска плагинов из маркетплейса,
которые могут ускорить реализацию.

Три способа выполнения:

1. Subagent-Driven (эта сессия) — Я запускаю свежий subagent на каждую задачу,
   делаю ревью между задачами. Вы наблюдаете.

2. Batch execution (отдельная сессия) — Откройте новый терминал, Claude выполняет
   задачи пакетами по 3, ждёт вашего фидбека между пакетами.

3. Autonomous (отдельная сессия) — Откройте новый терминал, Claude работает
   автономно через subagents с авто-ревью. Вы проверяете результат когда готово.

Какой подход?

Вы: 1

Claude: [Запускает subagent-driven-development]
```

### /forge:execute-plan

**Что делает:** Загружает готовый план и выполняет его пакетами по 3 задачи. После каждого пакета — пауза для вашего фидбека.

**Когда использовать:** Когда выбрали "Batch execution" или хотите выполнить план из другой сессии.

**Пример:**
```
Вы: /forge:execute-plan docs/plans/2026-02-15-jwt-auth.md

Claude: План загружен. 15 задач найдено.

Выполняю задачи 1-3:

Task 1: Установить Flask-JWT-Extended
[выполняет]
✓ Установлено

Task 2: Создать конфиг для JWT
[выполняет]
✓ Создан config/jwt.py

Task 3: Написать тест для /login эндпоинта
[выполняет]
✓ Тест создан, падает как ожидается

Пакет 1 завершён. Готов к фидбеку.

Вы: Продолжай

Claude: [Выполняет задачи 4-6]
```

### /forge:discover

**Что делает:** Анализирует план реализации и ищет плагины в маркетплейсе Claude Code, которые могут помочь. Пока маркетплейс API недоступен — показывает что будет искать.

**Когда использовать:** После написания плана, перед началом реализации.

**Пример:**
```
Вы: /forge:discover

Claude: Я проанализировал ваш план и нашёл следующие области:

Технологии:
- Flask, JWT, PostgreSQL

Домены:
- Authentication, Security

Паттерны:
- Token management, Session handling

⚠️ Поиск в маркетплейсе пока недоступен.

Что я буду искать когда API станет доступен:
- flask — для [работы с эндпоинтами]
- jwt — для [токенов и аутентификации]
- security — для [валидации и защиты]

Варианты сейчас:
1. Продолжить без плагинов маркетплейса
2. Создать кастомный скилл (требуется одобрение)
3. Поискать вручную в документации Claude Code

Какой вариант?
```

## Workflow

### Старт нового проекта

**Шаг 1: Инициализация**
```
/forge:init
```

**Шаг 2: Первая фича**
```
/forge:brainstorm
```
Опишите что хотите построить → Claude задаёт вопросы → одобряете дизайн → автоматически создаётся план.

**Шаг 3: Реализация**
Выбираете способ выполнения (Subagent-Driven, Batch, Autonomous) → Claude пишет код с тестами.

**Шаг 4: Sync**
```
/forge:sync
```
Обновите документацию после завершения.

### Добавление новой фичи

**1. Brainstorm — от идеи к дизайну**
```
Вы: /forge:brainstorm
Хочу добавить кэширование результатов API

Claude: [Загружает контекст из docs/]
Уточню: кэш для всех эндпоинтов или только для определённых?

Вы: Только для /api/indicators/*

Claude: Какое время жизни кэша?

Вы: 5 минут

Claude: [Задаёт ещё вопросы, предлагает подходы]

Вы: [Одобряете дизайн]

Claude: Дизайн сохранён. Создаю план реализации.
```

**2. Write Plan — детальный план**
```
Claude: План готов: docs/plans/2026-02-15-api-caching.md

12 задач:
- Task 1: Установить redis-py
- Task 2: Создать конфиг для Redis
- Task 3: Написать тест для cache decorator
...

Выберите способ выполнения.

Вы: Subagent-Driven
```

**3. Execute — реализация через subagents**
```
Claude: Использую subagent-driven-development.

Task 1: Установить redis-py
[Запускает implementer subagent]
Implementer: Установка завершена.
[Запускает spec reviewer]
Spec reviewer: ✓ Соответствует спецификации
[Запускает code quality reviewer]
Code reviewer: ✓ Качество хорошее
[Запускает forge-documenter]
Documenter: Обновил docs/library/

✓ Task 1 завершена

Task 2: Создать конфиг для Redis
[Повторяет цикл]
```

**4. Finish — завершение**
```
Claude: Все задачи выполнены. Тесты проходят (24/24).

Что вы хотите сделать?

1. Слить в main локально
2. Запушить и создать Pull Request
3. Оставить ветку как есть
4. Отменить эту работу

Вы: 2

Claude: [Пушит ветку, создаёт PR с описанием]

✓ PR создан: https://github.com/...
```

### Исправление бага

**1. Systematic Debugging — найти причину**
```
Вы: Тесты падают с ошибкой "Cache key not found"

Claude: Использую systematic-debugging.

Phase 1: Root Cause Investigation

Читаю ошибку:
[показывает stack trace]

Воспроизвожу:
pytest tests/test_cache.py::test_cache_miss -v
✓ Воспроизводится стабильно

Проверяю недавние изменения:
git log -5 --oneline
[показывает коммиты]

Последний коммит изменил cache key format.

Трейсинг:
- cache.get(key) возвращает None
- key = f"api:{endpoint}:{params}"
- Но в Redis ключи: f"api_{endpoint}_{params}"

Корневая причина: несовпадение формата ключа между get и set.
```

**2. Fix с TDD**
```
Claude: Phase 4: Implementation

Шаг 1: Создаю failing test
[Пишет тест test_cache_key_format]

Шаг 2: Запускаю — падает как ожидается
FAIL: AssertionError: Key format mismatch

Шаг 3: Фикс
[Меняет разделители в set() на ":" вместо "_"]

Шаг 4: Запускаю — проходит
PASS: test_cache_key_format
PASS: все остальные тесты (25/25)

Коммит:
git commit -m "fix: use consistent cache key format"
```

### Возвращение к проекту после перерыва

**Claude автоматически загружает контекст:**
```
[Вы открываете проект через неделю]

Claude: [При старте сессии читает docs/]

Я загрузил контекст проекта:

Проект: trading-bot (Python)
Структура: 5 директорий, 28 файлов
Красные зоны: 4 файла

Последняя сессия: 2026-02-08
Текущая задача: Добавить кэширование API (11/12 задач выполнено)
Осталось:
- Добавить мониторинг попаданий в кэш

Хотите продолжить с этой задачи?

Вы: Да

Claude: [Загружает план, показывает оставшиеся задачи]
```

**Если забыли что делали:**
```
Вы: Что у нас было в прошлый раз?

Claude: [Читает docs/state.json и docs/history.log]

2026-02-08: Добавление кэширования API (11 файлов изменено)
- Установили Redis
- Создали cache decorator
- Добавили тесты для всех эндпоинтов
- Осталось: мониторинг попаданий

Последние изменения:
- cache/redis_client.py — создан
- api/decorators.py — изменён
- tests/test_cache.py — создан
```

## Скиллы

Скиллы — это процессы и техники, которые Claude использует автоматически. Вам не нужно их вызывать вручную (кроме случаев когда явно указано).

### Планирование

#### brainstorming
Превращает идею в продуманный дизайн. Задаёт вопросы, предлагает варианты, получает одобрение, записывает документ.

**Когда:** Перед любой новой фичей или большим изменением.

#### writing-plans
Создаёт детальный план реализации с мелкими задачами по 2-5 минут каждая. Точные команды, пути к файлам, ожидаемый вывод.

**Когда:** Автоматически после brainstorming.

### Выполнение

#### executing-plans
Выполняет план пакетами по 3 задачи, делает паузу для фидбека между пакетами.

**Когда:** Batch execution в отдельной сессии.

#### subagent-driven-development
Выполняет план запуская свежий subagent на каждую задачу. Двухэтапное ревью после каждой: сначала соответствие спецификации, потом качество кода.

**Когда:** Subagent-Driven в текущей сессии или Autonomous в отдельной.

### Качество

#### test-driven-development (TDD)
Железное правило: тест → смотрим как падает → пишем код → смотрим как проходит. Никакого кода без теста.

**Когда:** Всегда при написании кода. Claude использует автоматически.

#### requesting-code-review
Вызывает subagent-ревьювера для проверки кода. Находит баги, проблемы качества, несоответствия спецификации.

**Когда:** После каждой задачи в subagent-driven, перед мержем, когда застряли.

#### verification-before-completion
Запрещает говорить "готово" без запуска проверки. Нет подтверждения → нет заявлений об успехе.

**Когда:** Автоматически перед любым "тесты проходят", "готово", "работает".

#### systematic-debugging
Четырёхфазный процесс: найти корневую причину → найти паттерн → сформировать гипотезу → написать тест и фикс. Никаких случайных фиксов.

**Когда:** При любом баге, падении теста, неожиданном поведении.

### Инфраструктура

#### using-git-worktrees
Создаёт изолированное рабочее пространство (git worktree) для работы над фичей. Не смешивается с вашей текущей веткой.

**Когда:** Автоматически при старте реализации плана.

#### finishing-a-development-branch
Завершает работу над фичей: проверяет тесты, предлагает 4 варианта (merge локально, создать PR, оставить как есть, отменить), выполняет выбор, чистит worktree.

**Когда:** Автоматически после завершения всех задач плана.

### Мета

#### writing-skills
TDD для скиллов — пишете тест (сценарий давления с subagent), смотрите как он падает, пишете скилл, смотрите как проходит, закрываете лазейки.

**Когда:** Создание или правка скиллов. Требует явного вызова.

#### forge-context
Загружает контекст проекта из docs/ вместо чтения всего кода. 2k токенов вместо 40k+.

**Когда:** Автоматически при старте сессии если есть docs/map.json.

## Структура docs/

### docs/map.json — карта проекта

```json
{
  "project": "trading-bot",
  "directories": {
    "indicators/": { "files": 5, "red_zone_files": 1 },
    "strategies/": { "files": 3, "red_zone_files": 2 }
  },
  "red_zones": [
    "indicators/rsi.py",
    "strategies/production_strategy.py"
  ]
}
```

**Для чего:** Claude сразу видит структуру, количество файлов, какие критичные.

### docs/conventions.json — правила проекта

```json
{
  "language": "python",
  "naming": {
    "files": "snake_case",
    "classes": "PascalCase",
    "functions": "snake_case"
  },
  "structure": {
    "indicators": "Каждый индикатор — чистая функция в своём файле",
    "strategies": "Каждая стратегия наследует BaseStrategy"
  },
  "patterns": {
    "new_indicator": "Создать файл в indicators/, добавить экспорт в __init__.py, добавить тест"
  },
  "decisions": {
    "pandas_not_polars": "Существующая кодовая база использует pandas, миграция не стоит того"
  }
}
```

**Для чего:** Claude пишет код в стиле проекта, следует вашим паттернам, помнит архитектурные решения.

### docs/state.json — текущее состояние

```json
{
  "current_task": "Добавить кэширование API",
  "progress": "11/12 задач выполнено",
  "last_session": "2026-02-15",
  "last_session_summary": "Настроил Redis, создал декоратор кэша, написал тесты",
  "pending": [
    "Добавить мониторинг попаданий в кэш"
  ],
  "recent_changes": [
    "cache/redis_client.py — создан",
    "api/decorators.py — изменён"
  ]
}
```

**Для чего:** Возвращаетесь к проекту через день/неделю — Claude знает где вы остановились.

### docs/library/[folder]/spec.json — что делает каждый файл

```json
{
  "purpose": "Индикаторы технического анализа — чистые функции",
  "files": {
    "macd.py": {
      "intent": "Рассчитать MACD индикатор (быстрая EMA - медленная EMA + сигнальная линия)",
      "inputs": ["df: DataFrame", "fast: int=12", "slow: int=26"],
      "outputs": "DataFrame с колонками macd, signal, histogram",
      "depends_on": ["pandas"],
      "red_zone": false
    }
  }
}
```

**Для чего:** Claude понимает назначение файла, его интерфейс, зависимости — без чтения кода.

### [folder]/README.md — описание для человека

```markdown
# Индикаторы

В этой папке лежат индикаторы технического анализа.
Каждый индикатор — отдельная функция в своём файле.

- **macd.py** — считает MACD (схождение-расхождение скользящих средних). Показывает момент когда быстрая средняя пересекает медленную.
- **rsi.py** — считает RSI (индекс относительной силы). Число от 0 до 100. ⚠️ Красная зона — от этого расчёта зависит рабочая стратегия.
```

**Для чего:** Вы (человек) открываете папку с кодом и сразу понимаете что здесь и зачем, на простом языке.

### docs/plans/[date]-[feature].md — дизайн и планы

Дизайн-документы из brainstorming и детальные планы реализации из writing-plans.

**Для чего:** История решений, можно вернуться к плану, понять почему сделали так.

### docs/history.log — лог сессий

```
2026-02-15 | Добавление кэширования API | 8 файлов изменено
2026-02-14 | Исправление бага с ключами кэша | 2 файла изменено
```

**Для чего:** Быстрый обзор что делалось в проекте. Claude не читает, но вы можете посмотреть.

## Частые вопросы

### Нужно ли вручную обновлять документацию?

**Нет.** `/forge:sync` делает это автоматически. Запускает subagent, который читает ваши изменения и обновляет все нужные файлы.

### Что если я изменил код но забыл запустить sync?

Ничего страшного. Запустите `/forge:sync` когда вспомните — он посмотрит на git diff с момента последнего sync и обновит документацию.

### Можно ли редактировать файлы в docs/ вручную?

**Да.** Особенно полезно редактировать `conventions.json` (добавить новые паттерны) и `map.json` (отметить новые красные зоны). Но обычно `/forge:sync` делает всё сам.

### Что такое "красная зона" и зачем она нужна?

Красная зона — файл, который требует особой осторожности:
- Production код, от которого зависит работающая система
- Сложный алгоритм, который легко сломать
- Файл с которым уже были проблемы

Claude видит красную зону и:
- Предупреждает вас перед изменением
- Делает более тщательное ревью
- Обязательно пишет тесты перед изменением

### Как работает Subagent-Driven Development?

Claude запускает **свежий subagent** на каждую задачу:
1. **Implementer** — пишет код, тесты, коммитит
2. **Spec reviewer** — проверяет соответствие спецификации (ничего лишнего, ничего не забыто)
3. **Code quality reviewer** — проверяет качество (читаемость, безопасность, паттерны)
4. **Forge documenter** — обновляет документацию

После каждого шага — проверка. Если нашли проблемы — фиксим и проверяем заново.

### Зачем нужны worktrees?

Git worktree — изолированная копия репозитория в отдельной папке. Работаете над фичей в worktree, ваша основная ветка остаётся нетронутой. Можете переключаться между задачами без stash/commit/reset.

### Можно ли использовать Forge на существующем проекте?

**Да.** Запустите `/forge:init` — он просканирует проект и создаст документацию для текущего состояния.

### Что если проект очень большой (сотни файлов)?

Forge особенно полезен для больших проектов! Вместо чтения сотен файлов (~100k+ токенов) Claude читает компактную документацию (~5k токенов) и понимает структуру.

### Нужно ли коммитить docs/ в git?

**Да, рекомендуется.** Документация полезна не только Claude, но и другим разработчикам. README.md в папках помогают людям понять код.

### Что делать если план слишком большой?

Brainstorming автоматически предложит разбить дизайн если он больше 150 строк. Лучше несколько маленьких фич чем одна огромная.

### Можно ли изменить красную зону после инициализации?

**Да.** Отредактируйте `docs/map.json`:
```json
{
  "red_zones": [
    "path/to/file.py"  // добавьте/уберите файлы здесь
  ]
}
```

Обновите счётчик `red_zone_files` для соответствующей директории.

### Как добавить свой паттерн в conventions.json?

Отредактируйте файл:
```json
{
  "patterns": {
    "new_api_endpoint": "Создать эндпоинт в routes/, написать тест в tests/routes/, добавить в OpenAPI spec"
  }
}
```

Claude будет следовать этому паттерну при создании новых эндпоинтов.

### Что если я не хочу использовать TDD?

Forge построен вокруг качественных практик включая TDD. Если вы пропускаете тесты, Claude будет напоминать о них. Вы можете игнорировать напоминания, но качество кода может пострадать.

### Можно ли использовать Forge с другими плагинами?

**Да.** Forge хорошо работает с другими плагинами Claude Code. `/forge:discover` даже может предлагать установку релевантных плагинов (когда маркетплейс API станет доступен).

### Как Forge помогает при code review?

`requesting-code-review` скилл запускает специализированный subagent-ревьювер:
- Проверяет соответствие требованиям
- Находит баги и уязвимости безопасности
- Оценивает качество кода
- Проверяет соблюдение conventions.json

Ревью происходит автоматически в subagent-driven-development.

### Что означают разные execution modes в writing-plans?

**Subagent-Driven (эта сессия):**
- Вы остаётесь в текущей сессии
- Наблюдаете как Claude работает
- Можете вмешаться в любой момент
- Подходит когда хотите контроль

**Batch execution (отдельная сессия):**
- Открываете второй терминал
- Claude работает в фоне пакетами по 3 задачи
- Пауза для фидбека между пакетами
- Подходит для параллельной работы

**Autonomous (отдельная сессия):**
- Открываете второй терминал
- Claude работает полностью автономно
- Проверяете результат когда всё готово
- Подходит для "уйти попить кофе, вернуться к готовому коду"

### Где хранятся скиллы Forge?

Скиллы встроены в плагин: `forge-plugin/skills/`. Вы можете читать их, но не нужно их вручную вызывать — Claude использует автоматически когда надо.

Свои кастомные скиллы можно создавать через `writing-skills` скилл и хранить в `~/.claude/skills/`.
